#include <AFMotor.h>

// Ce programme est téléversé dans la carte Arduino Mega et transforme des réceptions Bluetooth en actions mécaniques

// Définitions des moteurs
AF_DCMotor motor1(1);  // Avant gauche
AF_DCMotor motor2(2);  // Avant droit
AF_DCMotor motor3(3);  // Arrière gauche
AF_DCMotor motor4(4);  // Arrière droit

// Câblage des capteurs ultrasons sur la carte arduino
const int trigAv = 30, echoAv = 31;   // Capteur Avant
const int trigDr = 36, echoDr = 37;   // Droit
const int trigG  = 42, echoG  = 43;   // Gauche

// Vitesses
int vitesseMoteur       = 170;   // Vitesse pour le mode automatique
int vitesseMoteurRecul   = 250;  // Vitesse pour les roues qui reculent lors d'une demande de virage
int vitesseMoteurs       = 200;  // Vitesse de base pour le mode manuel

// Description des Modes :
// 'm' = Manuel, 'o' = Déplacement Libre 1 , 'p' = Déplacement Libre 2,
// 'v' = Avance jusqu'à 50cm, 'w' = Approche lente jusqu'à 15cm,
// 'j' = Pilotage vocal

char mode = 'm';  // mode actif initialement

void setup() {
  Serial.begin(9600);
  Serial2.begin(115200); // HM-10 sur RX17/TX18

  pinMode(trigAv, OUTPUT); pinMode(echoAv, INPUT);
  pinMode(trigDr, OUTPUT); pinMode(echoDr, INPUT);
  pinMode(trigG,  OUTPUT); pinMode(echoG,  INPUT);

  afficherVitesse();
}

void loop() {
  // Lecture des commandes Bluetooth
  if (Serial2.available()) {
    char command = Serial2.read();

    // Changement de mode
    if (command=='m'||command=='o'||command=='p'
     || command=='v'||command=='w'||command=='j') {
      mode = command;
      arreterMoteurs();
      Serial.println(mode);
    }

    // Distance sonar sur demande
    if (command == 'l') {
      int d_cm = mesurerDistance(trigAv, echoAv);
      Serial.println(d_cm * 10);  // mm
    }

    // Mode manuel Réceptions et actions
    if (mode == 'm') {
      switch (command) {
        case 'z': avancer();       break;
        case 's': reculer();       break;
        case 'q': tournerGauche(); break;
        case 'd': tournerDroite(); break;
        case 'x': arreterMoteurs();break;
        case 'a': augmenterVitesse(); break;
        case 'e': diminuerVitesse();  break;
        default:
          Serial.println("❓ Commande inconnue.");
      }
    }
    // Mode vocal
    else if (mode == 'j') {
      switch (command) {
        case 't': avancer();       break;
        case 'g': reculer();       break;
        case 'f': tournerGauche();  break ;      
        case 'h': tournerDroite(); break;
        case 'a': augmenterVitesse(); break;
        case 'e': diminuerVitesse();  break;
        break;
        case 'x': arreterMoteurs();break;
       
        default:
          Serial.println("❓ Commande inconnue.");
      }
    }
  }

  // Modes automatiques et spéciaux
  if (mode == 'o') {
    deplacementEtoile();
  }
  else if (mode == 'p') {
    deplacementA1();
  }
  else if (mode == 'v') {
    // Avance continu jusqu'à 50 cm
    if (mesurerDistance(trigAv, echoAv) > 50) {
      avancer();
    } else {
      arreterMoteurs();
      mode = 'm';
    }
  }
  else if (mode == 'w') {
    // Approche lente par impulsions jusqu'à 15 cm
    if (mesurerDistance(trigAv, echoAv) > 15) {
      avancer();
      delay(200);
      arreterMoteurs();
    } else {
      arreterMoteurs();
      mode = 'm';
    }
  }
   
  }

// ------- Fonctions de base -------

void avancer() {
  motor1.setSpeed(vitesseMoteurs); motor1.run(FORWARD);
  motor2.setSpeed(vitesseMoteurs); motor2.run(FORWARD);
  motor3.setSpeed(vitesseMoteurs); motor3.run(FORWARD);
  motor4.setSpeed(vitesseMoteurs); motor4.run(FORWARD);
}

void reculer() {
  motor1.setSpeed(vitesseMoteurs); motor1.run(BACKWARD);
  motor2.setSpeed(vitesseMoteurs); motor2.run(BACKWARD);
  motor3.setSpeed(vitesseMoteurs); motor3.run(BACKWARD);
  motor4.setSpeed(vitesseMoteurs); motor4.run(BACKWARD);
}

void tournerGauche() {
  motor1.setSpeed(200); motor1.run(BACKWARD);
  motor2.setSpeed(200); motor2.run(FORWARD);
  motor3.setSpeed(200); motor3.run(BACKWARD);
  motor4.setSpeed(200); motor4.run(FORWARD);
}

void tournerDroite() {
  motor1.setSpeed(200); motor1.run(FORWARD);
  motor2.setSpeed(200); motor2.run(BACKWARD);
  motor3.setSpeed(200); motor3.run(FORWARD);
  motor4.setSpeed(200); motor4.run(BACKWARD);
}

void arreterMoteurs() {
  motor1.run(RELEASE);
  motor2.run(RELEASE);
  motor3.run(RELEASE);
  motor4.run(RELEASE);
}

void augmenterVitesse() {
  vitesseMoteurs += 15;
  if (vitesseMoteurs > 255) vitesseMoteurs = 255;
  afficherVitesse();
}

void diminuerVitesse() {
  vitesseMoteurs -= 15;
  if (vitesseMoteurs < 0) vitesseMoteurs = 0;
  afficherVitesse();
}

void afficherVitesse() {
  Serial.print("Vitesse moteurs = ");
  Serial.println(vitesseMoteurs);
}

void setAllMoteurs(uint8_t sens) {
  motor1.setSpeed(vitesseMoteurs); motor1.run(sens);
  motor2.setSpeed(vitesseMoteurs); motor2.run(sens);
  motor3.setSpeed(vitesseMoteurs); motor3.run(sens);
  motor4.setSpeed(vitesseMoteurs); motor4.run(sens);
}

// ------- Modes automatiques -------

void deplacementEtoile() {
  int dAv = mesurerDistance(trigAv, echoAv);
  int dDr = mesurerDistance(trigDr, echoDr);
  int dG  = mesurerDistance(trigG,  echoG);

  if (dAv > 70) {
    avancer2();
  } else {
    if (dDr < 55 && dG < 55) {
      if (dDr > dG) tournerDroite2();
      else              tournerGauche2();
    } else if (dDr > 55) {
      tournerDroite2();
    } else {
      tournerGauche2();
    }
  }
  delay(200);
}

void avancer2() {
  motor1.setSpeed(vitesseMoteur); motor1.run(FORWARD);
  motor2.setSpeed(vitesseMoteur); motor2.run(FORWARD);
  motor3.setSpeed(vitesseMoteur); motor3.run(FORWARD);
  motor4.setSpeed(vitesseMoteur); motor4.run(FORWARD);
}

void tournerGauche2() {
  reculerUnPeu();
  motor1.setSpeed(vitesseMoteurRecul); motor1.run(BACKWARD);
  motor2.setSpeed(vitesseMoteur);       motor2.run(FORWARD);
  motor3.setSpeed(vitesseMoteurRecul);  motor3.run(BACKWARD);
  motor4.setSpeed(vitesseMoteur);       motor4.run(FORWARD);
  delay(400);
  arreterMoteurs();
}

void tournerDroite2() {
  reculerUnPeu();
  motor1.setSpeed(vitesseMoteur);      motor1.run(FORWARD);
  motor2.setSpeed(vitesseMoteurRecul); motor2.run(BACKWARD);
  motor3.setSpeed(vitesseMoteur);      motor3.run(FORWARD);
  motor4.setSpeed(vitesseMoteurRecul); motor4.run(BACKWARD);
  delay(400);
  arreterMoteurs();
}

void reculerUnPeu() {
  motor1.setSpeed(vitesseMoteur); motor1.run(BACKWARD);
  motor2.setSpeed(vitesseMoteur); motor2.run(BACKWARD);
  motor3.setSpeed(vitesseMoteur); motor3.run(BACKWARD);
  motor4.setSpeed(vitesseMoteur); motor4.run(BACKWARD);
  delay(300);
  arreterMoteurs();
}

void deplacementA1() {
  int dAv = mesurerDistance(trigAv, echoAv);
  int dDr = mesurerDistance(trigDr, echoDr);
  int dG  = mesurerDistance(trigG,  echoG);

  if (dAv > 70) {
    avancer();
  } else {
    if (dDr < 55 && dG < 55) {
      if (dDr > dG) tournerDroite();
      else              tournerGauche();
    } else if (dDr > 55) {
      tournerDroite();
    } else {
      tournerGauche();
    }
  }
  delay(200);
}

// Mesure ultrason
int mesurerDistance(int trig, int echo) {
  digitalWrite(trig, LOW);
  delayMicroseconds(2);
  digitalWrite(trig, HIGH);
  delayMicroseconds(10);
  digitalWrite(trig, LOW);

  long duree = pulseIn(echo, HIGH, 20000);
  int distance = duree * 0.034 / 2;  // en cm

  if (distance == 0 || distance > 200) return 200;
  return distance;
}